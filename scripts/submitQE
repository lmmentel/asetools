#!/usr/bin/env python
'''Script used to generate the submission script for SLURM and sbatch the job'''

from string import Template
import os,numpy
from argparse import ArgumentParser

def main():

    parser = ArgumentParser(usage='Script used to generate submission script for SLURMand submit the (mpi) job.')
    group = parser.add_mutually_exclusive_group()

    parser.add_argument('--name',
                        default = os.getcwd()[-8:],
                        help='Name of job. Default: extracted from submission path')
    parser.add_argument('--project',
                        dest='pno',
                        default='nn4683k',
                        help='NOTUR project number. Retrieve it with PROJECT command.')
    parser.add_argument('-i',
                        '--input',
                        default='input.py',
                        help='Name of input file(s) that you want copied to the compute node. Default=input.py')
    group.add_argument("-n",
                       "--nodes",
                       default="1",
                       help="number of nodes, default=1")
    group.add_argument("-H",
                       "--HOST",
                       default="",
                       help="destination hostname, default=''")
    parser.add_argument('--native',
                        action="store_true",
                        default=False,
                        help='Runs internal espresso routines, instead of through the ase-espresso interface')
    parser.add_argument('-n',
                        '--ncpu',
                        default='16',
                        help='Number of cores. Default=16 (one full node)')
    parser.add_argument('--dryrun',
                        action='store_true',
                        default=False,
                        help='Create sbatch script, but do not submit.')

    args = parser.parse_args()

    submit(args)

def submit(args, batch="PBS"):
    '''
    Submit a job to the batch system defined by the "batch" variable with the
    job details specified in the args object.

    batch: (str)
        name of the batch system:  "PBE", "SLURM", "LoadLeveller"
    args: ArgumentParse obj
        arguments specifying the job
    '''
    
    submitters = {"pbe" : submit_pbe,
                  "slurm" : submit_slurm,
                 }

    submitter = submitters.get(batch.lower(), None)
    if submitter is not None:
        submitter(args)
    else:
        raise NotImplementedError("support for '{0:s}' is not implemented \
                supported batch systems are: {}".format(batch), ", ".join(submitters.keys()))


def submit_slurm(args):

    #args[0] #should be time in format hh:mm:ss
    if int(args.ncpu) >= 16:
        ncpu_pernode = 16
    else:
        ncpu_pernode = int(args.ncpu)
    nnodes = int(numpy.ceil(int(args.ncpu)/16.0)) #NB: means that for >16 CPUs, the script will automatically fully allocate all nodes, i.e. up to 15 more CPUs than requested
    cpupars = '--nodes=%s --ntasks-per-node=%d' % (nnodes,ncpu_pernode)

    modules = 'espresso/5.0.3_beef' #5.0.3 is 5.0.2 with openmpi1.8
    commands = 'python ' + args.input
    cleanup = ''
    chkfiles = ''
    if args.nativeQE:
        #commands = 'cp *.inp $SCRATCH\ncd $SCRATCH\nmpirun pw.x < pw.inp > pw.out\npwlog2traj pw.out dyn.traj\nmpirun ph.x < ph.inp > ph.out\nmpirun dynmat.x < dynmat.inp > dynmat.out'
        commands = 'cp *.inp $SCRATCH\ncd $SCRATCH\nmpirun pw.x < pw.inp > pw.out\nmpirun ph.x < ph.inp > ph.out\nmpirun dynmat.x < dynmat.inp > dynmat.out'
        cleanup = 'cp -r pw.out dyn.traj ph.out dynmat.dat dynmat.out dynmat.mold calc.save _ph0/calc.phsave $SUBMITDIR'

    with open(os.getenv("HOME")+'/bin/SLURMtemplate.py','r') as ftemp:
        template = Template(ftemp.read())

    with open('submscript','w') as finp:
        finp.write(template.substitute(jobname=args.name, projectno=args.pno,
                                       time=args[0], cpupars=cpupars, modules=modules,
                                       SCRATCH='$SCRATCH', SUBMITDIR='$SUBMITDIR',
                                       JOB_ID='$JOB_ID', HOME='$HOME',
                                       chkfiles=chkfiles, commands=commands,
                                       cleanupcommand=cleanup))

    if not args.dryrun:
        os.system('mysbatch submscript')

def submit_pbs(args):
    '''
    Write the run script for PBS and submit it to the queue.
    '''

    with open(args['script_name'], 'w') as script:
        script.write("#PBS -S /bin/bash\n")
        if args['HOST'] != "":
            script.write("#PBS -l nodes={0}:ppn={1}\n".format(args['HOST'], args['ppn']))
        else:
            script.write("#PBS -l nodes={0}:ppn={1}\n".format(args['nodes'], args['ppn']))
        script.write("#PBS -l walltime={0}\n\n".format(args['walltime']))
        if args['libs'] is not None:
            script.write('export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:{0:<s}\n\n'.format(":".join(args['libs'])))
        script.write("cd $PBS_O_WORKDIR\n")
        if args['scratch']:
            wrkdir = os.path.join(args['scratch'], args['jobname'])
            script.write("mkdir -p {}\n".format(wrkdir))
            files = args['input']
            if args['extrafiles']:
                files += ' ' + ' '.join(args['extrafiles'])
            script.write('cp -t {0} {1}\n'.format(wrkdir, files))
            script.write('cd {0}\n'.format(wrkdir))
        script.write("\n/share/apps/bin/mpirun -np {0} {1:<s} -in {2:<s} \n".format(args['ppn'],
                     args['executable'], args['input']))

    # submit the job to the queue if requested
    if args['dryrun']:
        print("Created job script: {0}\n NOT submitting to the queue\nbye...".format(args['script_name']))
    else:
        print("Created job script: {0}\nsubmitting to the queue".format(args['script_name']))
        sublog = open(args['jobname'] + ".sublog", 'w')
        proc = subprocess.Popen(["qsub", "-q", args['queue'], "-N", args['jobname'], args['script_name']], stdout=sublog, stderr=sublog)
        sublog.close()

if __name__ == "__main__":
    main()
